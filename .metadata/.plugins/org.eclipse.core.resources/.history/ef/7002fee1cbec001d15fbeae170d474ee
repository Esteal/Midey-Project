package fr.midey.MagicUHC.Magie.Eau;

import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.scheduler.BukkitRunnable;
import org.bukkit.util.Vector;

import fr.midey.MagicUHC.MagicUHC;

public class Geyser implements Listener {

	private static MagicUHC main;
	
	public Geyser(MagicUHC main) {
		Geyser.main = main;
	}
	
	@EventHandler
	public void onGeyser(PlayerInteractEvent e) {
		ItemStack it = e.getItem();
		if(it == null) return;
		//if(!main.game) return;
		Player p = e.getPlayer();
		//if(main.getPlayerNature().get(p).equals(Nature.Eau)) {
			if(it.hasItemMeta() && it.getItemMeta().hasDisplayName() &&it.getItemMeta().getDisplayName().equalsIgnoreCase("§9Geyser") && it.getType().equals(Material.NETHER_STAR)) {
				Location ploc = p.getLocation();
				World world = ploc.getWorld();
				Vector v = ploc.getDirection();
				v.multiply(8);
				Location newLoc = new Location(world, v.getX() + ploc.getBlockX(), v.getY() + ploc.getBlockY(), v.getZ() + ploc.getBlockZ());
				WaterCooldown cd = new WaterCooldown();
				cd.cooldown = 15;
				while(newLoc.getBlock().getType() == Material.AIR) {
					newLoc.setY(newLoc.getBlockY() - 1);
				}
				Location towerLocation = newLoc; // L'emplacement où la tour doit être générée
				Material blockType = Material.WATER; // Le type de bloc que vous voulez utiliser pour la tour

				for (int i = 0; i < 8; i++) {
				    Location floorLocation = towerLocation.clone().add(0, i, 0);

				    // Génère le premier cercle de blocs
				    for (int x = -1; x <= 1; x++) {
				        for (int z = -1; z <= 1; z++) {
				            Location blockLocation = floorLocation.clone().add(x, 0, z);
				            blockLocation.getBlock().setType(blockType);
				            blockLocation.getBlock().getState().update(true, false);
				            removeBlockLater(blockLocation.getBlock(), 3); // Supprime le bloc 3 tics plus tard
				        }
				    }

				    // Génère le deuxième cercle de blocs
				    for (int x = -2; x <= 2; x++) {
				        for (int z = -2; z <= 2; z++) {
				            if (Math.abs(x) == 2 || Math.abs(z) == 2) {
				                Location blockLocation = floorLocation.clone().add(x, 0, z);
				                blockLocation.getBlock().setType(blockType);
				                blockLocation.getBlock().getState().update(true, false);
				                removeBlockLater(blockLocation.getBlock(), 3); // Supprime le bloc 3 tics plus tard
				            }
				        }
				    }
				}
			//}
		}
	}
	public void removeBlockLater(Block block, int delayTicks) {
	    Bukkit.getScheduler().runTaskLater(main, () -> {
	        block.setType(Material.AIR);
	    }, delayTicks);
	}

}
